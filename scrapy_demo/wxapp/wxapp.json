{
  "title": "使用gulp构建微信小程序开发工作流 ",
  "author": "Rolan",
  "pub_time": "2020-3-25 00:36",
  "content": ",web开发基本上都是基于webpack或者其他的构建工具来进行开发，大大节约了开发者的时间。目前的微信,小程序,开发也有很多开源的框架可供选择，但是如果使用原生开发模式，虽然可以完美使用小程序原生的新特性和功能，但是工作流角度上却十分简陋。,19年末的时候公司要开发一个新的小程序，组里面的大佬同事提议使用gulp来构建下原生开发模式的工作流。一是为了摆脱简陋的工作流模式以节约开发时间，二是也是把技术用到刀刃上。在大佬的指导开发下，这个工作便进行了。总体来说这个工作并不难，增益可能也没有那么大，但是还是收获了很多。,项目地址： ,gulp-mp,工作流改进,我们把开发目录设置在 ,src, ，输出目录设置在 ,dist, ，定义开发与输出路径。,文件复制,微信小程序的page目录通常包含 ,wxml, , ,json, , ,wxss, 和 ,js, 文件，与原生开发模式不同的是我们使用 ,sass, 预处理器来写样式，其他的文件保持原样不同。因此，对于 ,wxml, , ,json, , ,js, 文件来说，仅仅需要copy就行。因为在项目中已经配置了 ,eslint+prettier, 来进行语法检查和代码美化，因此不需要在工作流的js代码进行规范检查。如果没有配置，可以安装 ,gulp-eslint, 执行eslint规范检查。,const, srcPath = ,\"./src/**\",;\r\n,const, distPath = ,\"./dist/\",;\r\n,const, wxmlFiles = [,`,${srcPath},/*.wxml`,];\r\n,const, jsFiles = [,`,${srcPath},/*.js`,, ,`!,${srcPath},/env/*.js`,];\r\n,const, jsonFiles = [,`,${srcPath},/*.json`,];\r\n\r\n,// copy wxml,\r\n,const, wxml = ,(), =>, {\r\n  ,return, gulp\r\n    .src(wxmlFiles, { ,since,: gulp.lastRun(wxml) })\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(wxml);\r\n\r\n,// 其他copy流类似,\r\n...\r\n复制代码,sass处理,上面我们提到使用 ,sass, 预处理来编写样式，在输出的时候我们需要把 ,scss, 样式转换成 ,wxss,， ,wxss, 就是普通的 ,css, 样式。这里，我们使用 ,gulp-sass, 插件转换scss样式。但是，需要注意的是在 ,scss, 文件中，我们可能会import相关样式，可能是公共样式也可能是varibale和minxin。,经过测试发现，当import公共样式，会把这个公共样式打包进当前页面。我们知道小程序的包是有大小限制的，如果在引入公共样式的时候还打包到当前页面，无疑是消耗掉了不必要的内存。所以，针对公共样式的import处理为，不交给sass处理，保留import并把后缀的.scss改成.wxss。,当import的是变量和mixin时，我们需要保留对其的sass处理，因此新建独立的目录存放以便识别。在这一场景下，变量和mixin的文件不再递归处理。,//存放variable和mixin的sass文件在被引用时直接导入，不引入dist目录中,\r\n,const, DIRECTIMPORT = [,\"/scss/\",, ,\"/font/\",];\r\n,const, sassFiles = [,`,${srcPath},/*.{scss, wxss}`,];\r\n\r\n,const, wxss = ,(), =>, {\r\n  ,return, gulp\r\n    .src([...sassFiles, ...DIRECTIMPORT.map(,item, =>, ,`!,${srcPath},/,${item},/*`,)], {\r\n      ,since,: gulp.lastRun(wxss)\r\n    })\r\n    .pipe(plumber({ ,errorHandler,: onError }))\r\n    .pipe(\r\n      tap(,file, =>, {\r\n        ,const, filePath = path.dirname(file.path);\r\n        ,//console.log(\"filepath\", filePath);,\r\n        file.contents = ,new, Buffer(\r\n            ,// 匹配@import,\r\n          ,String,(file.contents).replace(\r\n            ,/@import\\s+['|\"](.+)['|\"];/g,,\r\n            ($,1,, $,2,) => {\r\n              ,console,.log(,\"$1\",, $,1,);\r\n              ,console,.log(,\"$2\",, $,2,);\r\n              ,//如果不是变量或者mixin则注释掉,\r\n              ,return, DIRECTIMPORT.some(,item, =>, {\r\n                ,return, $,2.,indexOf(item) > ,-1,;\r\n              })\r\n                ? $,1,\r\n                : ,`/** ,${$,1,}, **/`,;\r\n            }\r\n          )\r\n        );\r\n      })\r\n    )\r\n    .pipe(sass())\r\n    .pipe(postcss([autoprefixer([,\"iOS >= 8\",, ,\"Android >= 4.1\",])]))\r\n    .pipe(\r\n      replace(,/(\\/\\*\\*\\s{0,})(@.+)(\\s{0,}\\*\\*\\/)/g,, ($,1,, $,2,, $,3,) => {\r\n        ,//console.log(\"$1\", $1);,\r\n        ,//console.log(\"$2\", $2);,\r\n        ,//console.log(\"$3\", $3);,\r\n        ,//去掉注释并修改scss后缀为wxss,\r\n        ,return, $,3.,replace(,/\\.scss/g,, ,\".wxss\",);\r\n      })\r\n    )\r\n    .pipe(rename({ ,extname,: ,\".wxss\", }))\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(wxss);\r\n复制代码,压缩图片文件,安装gulp-imagemin插件压缩图片。之前通过npm安装在使用的时候这个插件总是报错，后来发现是没有正确安装，瞎倒腾切换到cnpm或者yarn发现可以安装成功了。,const, imageFiles = [\r\n  ,`,${srcPath},/images/*.{png,jpg,gif,ico}`,,\r\n  ,`,${srcPath},/images/**/*.{png,jpg,gif,ico}`,\r\n];\r\n,const, img = ,(), =>, {\r\n  ,return, gulp\r\n    .src(imageFiles, { ,since,: gulp.lastRun(img) })\r\n    .pipe(imagemin())\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(img);\r\n复制代码,区分开发环境,正常开发过程中，开发，测试和发布环境通常会有不同的API接口和其他设置。在每次切换的时候手动去更改内部代码是一件很麻烦的事情，也容易遗忘，根据不同的命令自动加载相应的开发环境设置才是我们想要的效果。 在 ,src/env/*, 目录下，配置了三个环境的变量： ,dev.js, ， ,test.js, ， ,prod.js, 。,const, envJs = ,env, =>, {\r\n  ,return, ,(), =>, {\r\n    ,return, gulp\r\n      .src(,`./src/env/,${env},.js`,)\r\n      .pipe(rename(,\"env.js\",))\r\n      .pipe(gulp.dest(distPath));\r\n  };\r\n};\r\ngulp.task(envJs);\r\n复制代码,清除dist目录,在重新编译的时候我们都需要清除dist目录的资源，以免导致混乱,/* 清除dist目录 */,\r\n,gulp,.task,(,\"clean\",, done => {\r\n  ,del,.sync,([,\"dist/**\",]);\r\n  ,done,();\r\n});\r\n复制代码,自动创建目录,使用命令新建page目录和component目录，只要把模版文件拷贝并重命名即可。,const, newfile = done => {\r\n  yargs\r\n    .example(,\"gulp newfile  -p mypage\",, ,\"创建mypage的page目录\",)\r\n    .example(,\"gulp newfile  -c mycomponent\",, ,\"创建mycomponent的component目录\",)\r\n    .example(\r\n      ,\"gulp newfile  -s srcfile -p mypage\",,\r\n      ,\"以srcfile为模版创建mypage的page目录\",\r\n    )\r\n    .option({\r\n      s: {\r\n        alias: ,\"src\",,\r\n        describe: ,\"模板\",,\r\n        ,type,: ,\"string\",,\r\n        ,default,: ,\"template\",\r\n      },\r\n      p: {\r\n        alias: ,\"page\",,\r\n        describe: ,\"page名称\",,\r\n        ,type,: ,\"string\",\r\n      },\r\n      c: {\r\n        alias: ,\"component\",,\r\n        describe: ,\"component名称\",,\r\n        ,type,: ,\"string\",\r\n      }\r\n    })\r\n    .fail(msg => {\r\n      done();\r\n      ,console,.error(,\"创建失败\",);\r\n      ,console,.log(msg);\r\n      ,console,.log(,\"help\",);\r\n      yargs.parse([,\"--msg\",]);\r\n    })\r\n    .help(,\"msg\",);\r\n\r\n  ,const, args = yargs.argv;\r\n  ,//console.log(\"args\", args);,\r\n  ,const, source = args.s;\r\n  ,const, filePaths = {\r\n    p: ,\"pages\",,\r\n    c: ,\"components\",\r\n  };\r\n\r\n  ,let, name,\r\n    ,type,,\r\n    hasParam = ,false,;\r\n  ,for, (,let, key ,in, filePaths) {\r\n    ,if, (args[key]) {\r\n      hasParam = ,true,;\r\n      name = args[key];\r\n      ,type, = filePaths[key];\r\n    }\r\n  }\r\n  ,if, (!hasParam) {\r\n    done();\r\n    yargs.parse([,\"--msg\",]);\r\n  }\r\n  ,const, defaultPath =\r\n    source === ,\"template\",\r\n      ? ,`src/,${source},/,${type},/*`,\r\n      : ,`src/,${type},/,${source},/*`,;\r\n  ,return, gulp.src(defaultPath).pipe(gulp.dest(,`src/,${type},/,${name},/`,));\r\n};\r\ngulp.task(newfile);\r\n复制代码,"
}
{
  "title": "功能完善的小程序日历组件 ",
  "author": "Rolan",
  "pub_time": "2020-4-1 00:21",
  "content": ",小程序,日历组件,\r\n,日历组件，表单组件绝逼是前端开发的一个噩梦，尤其要做好一个旅游项目的日历，变态需求特别多，要在小程序中实现携程app的日历，还要兼顾性能问题。,\r\n,\r\n,\r\n,自定义横向/纵向日历,\r\n,自定义区间大小,\r\n,自定义日期内容,\r\n,指定节假日,\r\n,支持跨月显示,\r\n,\r\n,难点,\r\n,\r\n,懒加载保证渲染性能,\r\n,通过配置实现纵向日历和横向日历,\r\n,阳历节日与农历节日与节气,\r\n,交互，尤其是区域选择的交互,\r\n,\r\n,\r\n,示例代码,\r\n,https://github.com/webkixi/aotoo-xquery \r\n=> pages/calendar    \r\n,复制代码,\r\n,配置说明,\r\n,wxml,\r\n,<ui-calendar dataSource=\"{{config}}\" />\r\n,复制代码,\r\n,js,\r\n,基本用法,\r\n,const Pager = require('../../components/aotoo/core/index')\r\nPager({\r\n  data: {\r\n    config: {\r\n      $$id: 'calendar',\r\n      mode: 1,  // 纵向日历\r\n      type: 'range',  // 区域选择\r\n      tap: 'onTap', // page响应事件\r\n      total: 365, // 定义从今天开始一年事件\r\n      rangeCount: 28,  // 区选区间28天\r\n      festival: true, // 开启节假日显示\r\n      value: ['2019-12-24', '2020-01-05'],  // 默认值\r\n      methods: { \r\n        // 响应 tap事件\r\n        onTap(e, param, inst) {\r\n          if (param.range === 'start') {\r\n            inst.update({dot: [{title: '入住'}]})\r\n          }\r\n          if (param.range === 'end') {\r\n            inst.update({dot: [{title: '离店'}]})\r\n            setTimeout(() => {\r\n              Pager.alert('离店，跳回页面')\r\n            }, 1000);\r\n          }\r\n          console.log(param);\r\n        }\r\n      }\r\n    }\r\n  }\r\n})\r\n,复制代码,\r\n,$$id,\r\n{String} 配置实例的Id,\r\n,mode,\r\n{Number} 设置日历的展示模式，1=纵向日历 2=横向日历,\r\n,type,\r\n{Number} single=单选日历， range=选择区间， multiple=多选日历,\r\n,total,\r\n{Number} 设置日历从今天开始起需要跨多少天，如 180天，或者365天,\r\n,start,\r\n{String} 设置起始日期，如：'2020-06-05',\r\n,date,\r\n{Object|Function} 定义附加日期内容,\r\n,disable,\r\n{Boolean} 设置全局无效，所有日期均不能交互，权重低于单个日期设置的disable,\r\n,rangeCount,\r\n{Number} 当type === 'range'时，rangeCount为区间大小，意味着区间允许选择多少天,\r\n,rangeMode,\r\n{Number} 当正在做日期区间选择时，是否允许显示angeCount之外的日期 1=显示， 2=不显示,\r\n,tap,\r\n{String} 响应日期元素的tap事件,\r\n,value,\r\n{Array} 默认选中的日期，允许数组为空，如果type='single'则应该设置如['2020-06-05']，type='range'应该设置如['2020-06-03', '2020-06-05'], type='multiple'时，数组允许多值,\r\n,data,\r\n{Array} 该数据会自动计算日期跨度数量(允许跨年设置)，如果设置了该数据，则total无效，如设置为['2019-11-05', '2021-11-05']，自动计算日期为730天,\r\n,festival,\r\n{Boolean|Array} 设置日历假期显示，支持显示指定假期,\r\n,toolbox,\r\n{Object} 日历的扩展配置，允许设置一些高级功能，如日历是否允许跨月，特殊的range算法等等,\r\n,toolbox.header,\r\n{Boolean} 是否显示日历的头部，一般用于横向日历时为true,\r\n,toolbox.monthHeader,\r\n{Boolean} 是否显示日历的月头部，一般在纵向日历时为true,\r\n,toolbox.rangeEdge,\r\n{Function} 默认值null，type='range'时，自定义range选择算法,\r\n,toolbox.discontinue,\r\n{Boolean} 默认false，当日历有data数组构建时，缺少数据的月份会被忽略,\r\n,如何设置,\r\n,设置横向、纵向日历,\r\n,let, calenderConfig = {\r\n  ,$$id,: ,'calendar',,\r\n  ,mode,: ,2,, ,// 1，纵向日历 2，横向日历,\r\n  type: ,'single',, ,// single：单选  range: 区间选择  multiple：多选,\r\n  tap: ,'onTap',, ,// 回调事件,\r\n  total: ,180,, ,// 所有日期选择天数,\r\n  methods: { ,// 响应方法,\r\n    onTap(e, param, inst) {\r\n      ,console,.log(param);\r\n    }\r\n  }\r\n}\r\n,复制代码,设置区间选择日历,\r\n,该示例配置为仿携程的功能设置,\r\n,let, calendarConfig = {\r\n  ,$$id,: ,'calendar',,  ,//实例id,\r\n  mode: ,1,,  ,// 纵向日历,\r\n  type: ,'range',,  ,// 区间选择日历,\r\n  tap: ,'onTap',, ,// tap响应方法,\r\n  total: ,365,,  ,// 指定日历从今天开始总天数,\r\n  rangeCount: ,28,, ,// 区间范围,\r\n  rangeMode: ,1,, ,// 区间选择是否隐藏非区间的月份,\r\n  festival: ,true,, ,// 是否显示节假日,\r\n  value: [,'2020-04-03',, ,'2020-04-09',],  ,// 默认值,\r\n  methods: { \r\n    ,// 定义响应方法  ,\r\n    onTap(e, param, inst) {\r\n      \r\n      ,if, (param.range === ,'start',) {  ,// 第一次点击时,\r\n        inst.update({,dot,: [{,title,: ,'入住',}]})\r\n      }\r\n      ,if, (param.range === ,'end',) { ,// 第二次点击时,\r\n        inst.update({,dot,: [{,title,: ,'离店',}]})\r\n      }\r\n      ,console,.log(param);\r\n    }\r\n  }\r\n}\r\n,复制代码,设置多选日历,\r\n,支持选中多个日期,\r\n,let, calenderConfig = {\r\n  ,$$id,: ,'calendar',,\r\n  ,mode,: ,2,,\r\n  ,type,: ,'multiple',, ,// single：单选  range: 区间选择  multiple：多选,\r\n  tap: ,'onTap',, ,// 回调事件,\r\n  total: ,180,, ,// 所有日期选择天数,\r\n  value: [,'2020-04-03',, ,'2020-04-09',, ,'2020-04-10',],\r\n  ,methods,: { ,// 响应方法,\r\n    onTap(e, param, inst) {\r\n      ,console,.log(param);\r\n    }\r\n  }\r\n}\r\n,复制代码,据已知日期自动构建,\r\n,此例中total无效，由两个给定的日期构建了三个月的日历,\r\n,let, calenderConfig = {\r\n  ,$$id,: ,'calendar',,\r\n  ,mode,: ,2,, ,// 1，纵向日历 2，横向日历,\r\n  type: ,'single',, ,// single：单选  range: 区间选择  multiple：多选,\r\n  tap: ,'onTap',, ,// 回调事件,\r\n  total: ,180,, ,// 所有日期选择天数，此例中无效  ,\r\n  data: [{,\"date\",:,\"2020-04-03\",}, {,\"date\",:,\"2020-06-03\",}],\r\n  ,methods,: { ,// 响应方法,\r\n    onTap(e, param, inst) {\r\n      ,console,.log(param);\r\n    }\r\n  }\r\n},\r\n,复制代码,根据已知日期自动构建，忽略无数据月份,\r\n,此例中total无效， 由两个给定的日期构建了三个月的日历,\r\n,let, calenderConfig = {\r\n  ,$$id,: ,'calendar',,\r\n  ,mode,: ,2,, ,// 1，纵向日历 2，横向日历,\r\n  type: ,'single',, ,// single：单选  range: 区间选择  multiple：多选,\r\n  tap: ,'onTap',, ,// 回调事件,\r\n  total: ,180,, ,// 所有日期选择天数，此例中无效,\r\n  data: [{,\"date\",:,\"2020-04-03\",}, {,\"date\",:,\"2020-06-03\",}],\r\n  ,toolbox,: {\r\n    ,discontinue,: ,true, ,// 允许构建跨月日历,\r\n  },\r\n  ,methods,: { ,// 响应方法,\r\n    onTap(e, param, inst) {\r\n      ,console,.log(param);\r\n    }\r\n  }\r\n},\r\n,复制代码,构建节假日日历,\r\n,允许指定节假日，指定节假日内容,\r\n,\r\n,\r\n,festival: true\r\n显示所有组件自带节日,\r\n,\r\n,\r\n,festival: ['元旦节', '情人节', '劳动节', '冬至'],\r\n显示指定假日,\r\n,\r\n,\r\n,festival: [{title: '春节', content: {dot: ['新年好']}}],\r\n显示指定节日，并附加内容,\r\n,\r\n,\r\n,let, calenderConfig = {\r\n  ,$$id,: ,'calendar',,\r\n  ,mode,: ,1,, ,// 1，纵向日历 2，横向日历,\r\n  type: ,'single',, ,// single：单选  range: 区间选择  multiple：多选,\r\n  tap: ,'onTap',, ,// 回调事件,\r\n  data: [{,\"date\",:,\"2020-09-03\",}, {,\"date\",:,\"2020-12-28\",}],\r\n  ,festival,: [,'教师节',, ,'圣诞节',],\r\n  ,toolbox,: {\r\n    ,discontinue,: ,true, ,// 允许忽略无数据月份,\r\n  },\r\n  ,methods,: { ,// 响应方法,\r\n    onTap(e, param, inst) {\r\n      ,console,.log(param);\r\n    }\r\n  }\r\n},\r\n,复制代码,自定义日期内容,\r\n,自定义日期内容有两种方法,\r\n,\r\n,\r\n,在data数据配置中加入'dot'数组属性,\r\n,config.data = [{date: '2020-03-03', content: {dot: ['内容']}}],\r\n,\r\n,\r\n,在date属性中配置,\r\n,\r\n,\r\n,// 配置所有日期的附加内容   ,\r\nconfig.date = {,dot,: [,'自定义内容',]}  \r\n\r\n,// 指定日期内容配置   ,\r\nconfig.date = ,function,(,param,),{\r\n  ,// 通过param的属性写逻辑 param.date, param.year, param.month, param.day ...,\r\n  ,if, (param.date === ,'2020-8-13',) {\r\n    param.dot = [,'附加内容',]\r\n    ,return, param\r\n  }\r\n}\r\n,复制代码,设置示例,\r\n,let, calenderConfig = {\r\n  ,$$id,: ,'calendar',,\r\n  ,mode,: ,2,, ,// 1，纵向日历 2，横向日历,\r\n  type: ,'single',, ,// single：单选  range: 区间选择  multiple：多选,\r\n  tap: ,'onTap',, ,// 回调事件,\r\n  date: ,function,(,param,),{\r\n    ,if, (param.month === ,12, && param.day === ,26,) {\r\n      param.dot = [,'毛主席诞辰',]\r\n      ,return, param\r\n    }\r\n    ,if, (param.month === ,9, && param.day === ,10,) {\r\n      param.dot = [\r\n        {,title,: ,'生日',, ,itemStyle,: ,'font-size: 11px; color: blue;',},\r\n        {,title,: ,'骗你的',, ,itemStyle,: ,'font-size: 11px; color: #666',},\r\n      ]\r\n      ,return, param\r\n    }\r\n    ,if, (param.month === ,9, && param.day === ,20,) {\r\n      param.dot = [\r\n        {,title,: ,'无效日期',, ,itemStyle,: ,'font-size: 12px; color: red;',},\r\n        {,title,: ,'不能交互',, ,itemStyle,: ,'font-size: 12px; color: #666;',},\r\n      ]\r\n      param.disable = ,true,\r\n      ,return, param\r\n    }\r\n  },\r\n  ,toolbox,: {\r\n    ,discontinue,: ,true,\r\n  },\r\n  ,data,: [{,\"date\",:,\"2020-09-03\",}, {,\"date\",:,\"2020-12-28\",}],\r\n  ,methods,: { ,// 响应方法,\r\n    onTap(e, param, inst) {\r\n      ,console,.log(param);\r\n    }\r\n  }\r\n},\r\n,复制代码,GITHUB源码,\r\n,示例小程序,\r\n,"
}
{
  "title": "小程序导航栏之导航面板 ",
  "author": "Rolan",
  "pub_time": "2020-4-2 00:55",
  "content": ",导航面板,\r\n,导航系统起着组织内容和功能的作用，让它们按照产品的信息架构图进行连接，展现在在用户面前，导航将零散的内容和功能组织成了一个完成的有结构的系统，有时我们需要把更多的内容放置在导航栏的位置，因此需要一个导航面板,\r\n,导航面板是导航栏的一个扩展，从导航栏部分拖拽出导航面板，展示更多的入口,\r\n,\r\n,\r\n,\r\n,\r\n,支持自定义面板内容,\r\n,\r\n,\r\n,示例代码,\r\n,https://github.com/webkixi/aotoo-xquery  \r\n=> pages/navpad  \r\n,复制代码,\r\n,配置说明,\r\n,const, Pager = ,require,(,'../../components/aotoo/core/index',)\r\n,const, mkNavpad = ,require,(,'../../components/modules/navpad',)\r\nPager({\r\n  ,data,: {\r\n    ,navPadConfig,: mkNavpad({\r\n      ,id,: ,'',,\r\n      ,bindopen,: ,null,,\r\n      ,bindclose,: ,null,,\r\n      ,content,: ,null,,\r\n      ,navpadHeight,: ,'90%',, ,// 默认导航板高度,\r\n      navpadTop: ,'85%',, ,// 默认导航板初始位置,\r\n      navpadOpen: ,'-80%', ,// 默认导航板打开高度,\r\n    }),\r\n  }\r\n})\r\n,复制代码,id,\r\n{Array} 配置实例的Id,\r\n,bindopen,\r\n{Function} 弹开导航面板时的回调方法,\r\n,bindclose,\r\n{Function} 关闭导航面板时的回调方法,\r\n,content,\r\n{Array} 设置导航面板的内容,\r\n,navpadHeight,\r\n{String} 设置导航面板的高度，默认为全屏90%,\r\n,navpadTop,\r\n{String} 设置导航面板的默认位置, 默认为85%,\r\n,navpadOpen,\r\n{String} 设置导航面板打开时的占整屏高度, 默认为80%,\r\n,如何设置,\r\n,设置回调函数,\r\n,navPadConfig: mkNavpad({\r\n  ,bindopen,: ,function,(,),{\r\n    ,// 导航栏面板弹开时响应,\r\n  },\r\n  ,bindclose,: ,function,(,),{\r\n    ,// 导航栏面板关闭时响应,\r\n  },\r\n  ,navpadHeight,: ,'90%',, ,// 默认导航板高度,\r\n  navpadTop: ,'85%',, ,// 默认导航板初始位置,\r\n  navpadOpen: ,'-80%', ,// 默认导航板打开高度,\r\n}),\r\n,复制代码,如何获得实例,\r\n,Pager({\r\n  ,data,: {\r\n    ,navPadConfig,: mkNavpad({\r\n      ,id,: ,'idName',,\r\n    }),\r\n  },\r\n  onReady(){\r\n    ,let, that = ,this,[idName]\r\n  }\r\n})  \r\n,复制代码,使用实例插入数据,\r\n,Pager({\r\n  ,data,: {\r\n    ,navPadConfig,: mkNavpad({\r\n      ,id,: ,'idName',,\r\n    }),\r\n  },\r\n  onReady(){\r\n    ,let, that = ,this,[idName]\r\n    ,// 插入一条数据,\r\n    that.innerContent({ ,title,: ,'好好学习，天天向上', })  \r\n\r\n    ,// 插入数组  ,\r\n    that.innerContent([\r\n      { ,title,: ,'好好学习', },\r\n      { ,title,: ,'天天向上', },\r\n    ])  \r\n    \r\n    ,// 追加数据  ,\r\n    that.appendContent([\r\n      { ,title,: ,'好好学习', },\r\n      { ,title,: ,'天天向上', },\r\n    ]) \r\n  }\r\n})\r\n,复制代码,设置文本内容,\r\n,mkNavpad({ ,content,: [\r\n  ,'好好学习',,\r\n  ,'天天向上',\r\n]})\r\n,复制代码,设置列表,\r\n,mkNavpad({ ,content,: [\r\n  {,title,: ,'好好学习',, ,itemClass,: ,'xuexi',},\r\n  {,title,: ,'天天向上',, ,itemClass,: ,'xiangshang',},\r\n  {,img,: {,src,: ,'path/to/img',, ,itemClass,: ,'img-class',}},\r\n]})\r\n,复制代码,设置文档,\r\n,mkNavpad({ \r\n  ,content,: [\r\n    {,\"@md\",: ,`markdown的文本内容`,}\r\n  ]\r\n})\r\n,复制代码,设置复杂的图文,\r\n,mkNavpad({\r\n  ,content,: [\r\n    {\r\n      ,img,: {,src,: ,'path/to/image',},\r\n      ,\"@md\",: ,`文档描述内容`,\r\n    },\r\n  ]\r\n})\r\n,复制代码,GITHUB源码,\r\n,查看演示,\r\n,"
}
{
  "title": "教你如何用华为HMS MLKit 图像分割 SDK开发一个证件照DIY小程序 ",
  "author": "Rolan",
  "pub_time": "2020-4-7 00:21",
  "content": ",引子,上期给大家介绍了如何使用如何用华为HMS MLKit SDK 三十分钟在安卓上开发一个微笑抓拍神器详情请戳，本次给大家分享一篇新的实战经验。,不知道大家是否有这样的经历，忽然学校或者公司需要提供让提供个人的一寸或者两寸头像照片，要办理出入证、学生证什么的，并且对照片的底色有要求，有很多人当前没有拍好的证件照需要到照相馆重拍，又或者之前已经拍过了，但是照片底色不满足要求，小编就有过类似的经历，当时学校让办个出入证，学校照相馆又关门了，匆匆忙忙用手机拍了下，然后用床单作为背景应付，结果被老师大骂了一顿。,多年以后华为的HMS MLKit机器学习有了图像分割的功能，使用这个SDK开发一个证件照DIY的,小程序,，可以完美解决小编当年遇到的尴尬。,废话不多说，为了能够制造强烈的视觉冲击，小编也是拼了，翻出来当年大学时代的囧照，给大家展示下华为 HMS MLKit的强大功能：,怎么样，效果是不是还可以，只需要写个小程序就可以快速实现！,核心提示：此SDK免费，安卓全机型覆盖！,证件照DIY开发实战,1 开发准备,1.1 在项目级gradle里添加华为maven仓,打开AndroidStudio项目级build.gradle文件。,增量添加如下maven地址：,buildscript, {\r\n    ,repositories, {        \r\n        ,maven, {,url, ,'http://developer.huawei.com/repo/',}\r\n    }    }allprojects {\r\n    ,repositories, {       \r\n        ,maven, { ,url, ,'http://developer.huawei.com/repo/',}\r\n    }},1.2 在应用级的build.gradle里面加上SDK依赖,把人脸识别的SDK和基础SDK引入,dependencies,{ \r\n  ,// 引入基础SDK ,\r\n  implementation ,'com.huawei.hms:ml-computer-vision:1.0.2.300', \r\n  ,// 引入人脸检测能力包 ,\r\n  implementation ,'com.huawei.hms:ml-computer-vision-image-segmentation-body-model:1.0.2.301',   \r\n  },1.3 在AndroidManifest.xml文件里面增量添加模型自动下载,要使应用程序能够在用户从华为应用市场安装您的应用程序后，自动将最新的机器学习模型更新到用户设备，请将以下语句添加到该应用程序的AndroidManifest.xml文件中：,<,manifest,    \r\n   <,application,  \r\n       <,meta-data,                     \r\n           ,android:name,=,\"com.huawei.hms.ml.DEPENDENCY\",          \r\n           ,android:value,= ,\"imgseg \",/>,                    \r\n   ,</,application,>,\r\n,</,manifest,>,1.4 在AndroidManifest.xml文件里面申请相机和存储权限,<!--使用存储权限-->,<,uses-permission, ,android:name,=,\"android.permission.WRITE_EXTERNAL_STORAGE\", />,2 代码开发关键步骤,2.1 动态权限申请,@Overrideprotected, ,void, ,onCreate,(Bundle savedInstanceState), ,{\r\n    ,super,.onCreate(savedInstanceState);\r\n    setContentView(R.layout.activity_main);\r\n    ,if, (!allPermissionsGranted()) {\r\n        getRuntimePermissions();\r\n    }},@Overridepublic, ,void, ,onRequestPermissionsResult,(,int, requestCode, @NonNull String[] permissions,\r\n                                       @NonNull ,int,[] grantResults), ,{\r\n    ,super,.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n\r\n    ,if, (requestCode != PERMISSION_REQUESTS) {\r\n        ,return,;\r\n    }\r\n    ,boolean, isNeedShowDiag = ,false,;\r\n    ,for, (,int, i = ,0,; i < permissions.length; i++) {\r\n        ,if, (permissions[i].equals(Manifest.permission.READ_EXTERNAL_STORAGE) && grantResults[i] != PackageManager.PERMISSION_GRANTED) {\r\n            ,// 如果相机或者存储权限没有授权，则需要弹出授权提示框,\r\n            isNeedShowDiag = ,true,;\r\n        }\r\n    }\r\n    ,if, (isNeedShowDiag && !ActivityCompat.shouldShowRequestPermissionRationale(,this,, Manifest.permission.CALL_PHONE)) {\r\n        AlertDialog dialog = ,new, AlertDialog.Builder(,this,)\r\n                .setMessage(getString(R.string.camera_permission_rationale))\r\n                .setPositiveButton(getString(R.string.settings), ,new, DialogInterface.OnClickListener() {\r\n                    ,@Override,                    \r\n                    ,public, ,void, ,onClick,(DialogInterface dialog, ,int, which), ,{\r\n                        Intent intent = ,new, Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\r\n                        intent.setData(Uri.parse(,\"package:\", + getPackageName())); ,// 根据包名打开对应的设置界面,\r\n                        startActivityForResult(intent, ,200,);\r\n                        startActivity(intent);\r\n                    }\r\n                })\r\n                .setNegativeButton(getString(R.string.cancel), ,new, DialogInterface.OnClickListener() {\r\n                    ,@Override,                    \r\n                    ,public, ,void, ,onClick,(DialogInterface dialog, ,int, which), ,{\r\n                        finish();\r\n                    }\r\n                }).create();\r\n        dialog.show();\r\n    }},2.2 创建图像分割检测器,可以通过图像分割检测配置器“MLImageSegmentationSetting”创建图像分割检测器。,MLImageSegmentationSetting, setting = ,new, ,MLImageSegmentationSetting,.,Factory,()\r\n                .setAnalyzerType(,MLImageSegmentationSetting,.,BODY_SEG,)\r\n                .setExact(,true,)\r\n                .create();        \r\n,this,.analyzer = ,MLAnalyzerFactory,.getInstance().getImageSegmentationAnalyzer(setting);,2.3 通过android.graphics.Bitmap创建“MLFrame”对象用于分析器检测图片,可以通过图像分割检测配置器“MLImageSegmentationSetting”创建图像分割检测器。,MLFrame mlFrame = ,new, MLFrame,.Creator,(),.setBitmap,(,this,.originBitmap,),.create,();,2.4 调用“asyncAnalyseFrame ”方法进行图像分割。,// 创建一个task，处理图像分割检测器返回的结果。 Task<MLImageSegmentation> task = analyzer.asyncAnalyseFrame(frame); // 异步处理图像分割检测器返回结果 Task<MLImageSegmentation> task = this.analyzer.asyncAnalyseFrame(mlFrame);,\r\n            task.addOnSuccessListener(new OnSuccessListener<MLImageSegmentation>() {\r\n                ,@Override,                ,public, void onSuccess(MLImageSegmentation mlImageSegmentationResults) {\r\n                    ,// Transacting logic for segment success.,\r\n                    ,if, (mlImageSegmentationResults != ,null,) {\r\n                        StillCutPhotoActivity.,this,.foreground = mlImageSegmentationResults.getForeground();\r\n                        StillCutPhotoActivity.,this,.preview.setImageBitmap(StillCutPhotoActivity.,this,.foreground);\r\n                        StillCutPhotoActivity.,this,.processedImage = ((BitmapDrawable) ((ImageView) StillCutPhotoActivity.,this,.preview).getDrawable()).getBitmap();\r\n                        StillCutPhotoActivity.,this,.changeBackground();\r\n                    } ,else, {\r\n                        StillCutPhotoActivity.,this,.displayFailure();\r\n                    }\r\n                }\r\n            }).addOnFailureListener(new OnFailureListener() {\r\n                ,@Override,                ,public, void onFailure(Exception e) {\r\n                    ,// Transacting logic for segment failure.,\r\n                    StillCutPhotoActivity.,this,.displayFailure();\r\n                    ,return,;\r\n                }\r\n            });,2.5 更换图片背景。,this,.backgroundBitmap = BitmapUtils.loadFromPath(StillCutPhotoActivity.,this,, id, targetedSize.first, targetedSize.second);BitmapDrawable drawable = new BitmapDrawable(backgroundBitmap);,this,.preview.setDrawingCacheEnabled(,true,);,this,.preview.setBackground(drawable);,this,.preview.setImageBitmap(,this,.foreground);,this,.processedImage = Bitmap.createBitmap(,this,.preview.getDrawingCache());,this,.preview.setDrawingCacheEnabled(,false,);,结后语,就这样，一款证件DIY的小程序就制作好了，给大家看下Demo的演示效果：,基于图像分割能力不仅仅可以用来做证件照DIY程序，还可以实现如下相关功能：,生活照的人像抠图，更换背景制作一些趣味的照片，或者对背景做虚化得到更美、更有艺术效果的照片。,识别图像中的天空、植物、美食、猫狗、花朵、水面等、沙面、建筑、山峰等元素，针对这些元素做特殊的美化，比如让天空更蓝，水更清澈。,识别视频流中的对象，对视频流进行特效编辑、更换背景。,其它功能请大家一起开脑洞吧！,更详细的开发指南参考华为开发者联盟官网,华为开发者联盟机器学习服务开发指南,往期链接： ,Android | 教你如何用华为HMS MLKit SDK 三十分钟在安卓上开发一个微笑抓拍神器,内容来源： ,https://developer.huawei.com/consumer/cn/forum/topicview?tid=0201203408959360433&fid=18,原作者：AI_talking,"
}
{
  "title": "小程序如何在业务系统中接入图片安全校验 ",
  "author": "Rolan",
  "pub_time": "2020-4-7 00:45",
  "content": ",在,小程序,开发的过程中，如果你的小程序中存在图片上传的能力，经常会遇到同一个原因被拒绝审核：「没有对上传信息做审核」，想要过审核也很简单，只要将用户上传的图片提交审核就可以了。而且，微信也提供了这样的接口给开发者，让开发者做接入。如果你使用了云开发，那就更加的简单，只需要使用云调用，一行代码就可以完成产品的调用。,如何使用云函数中接入图片安全校验,不少人看过一个视频，里面的代码大致是这样写的，很简单，但很有效的完成了图片的安全检测,// 云函数入口文件,\r\n,const, cloud = require(,'wx-server-sdk',)\r\n\r\ncloud.init()\r\n\r\n,// 云函数入口函数,\r\nexports.main = ,async, (,event,, context) => {\r\n  ,const, img = (,await, cloud.downloadFile({\r\n    fileID:,event,.fileID\r\n  })).fileContent;\r\n  ,return, ,await, cloud.openapi.security.imgSecCheck({\r\n    media:{\r\n      contentType:,'image/png',,\r\n      ,value,:img\r\n    }\r\n  });\r\n},这段代码在绝大多数情况下都是不会出现运行问题的，但是，这个大多数情况是指 ,这个图片没有安全问题, ，如果这个图片的内容有问题，你的小程序运行就会报错，就像下面这样。,这样的报错有问题么？没有的，因为这个就是系统的运行机制，但是，这样的问题如果不做处理，就会在实际应用过程中出现问题。,这段报错的意思是： 由于检测的内容出现了问题，导致系统出现了异常，从未抛出了一个异常，在这种情况下，开发者需要做的就是捕获这个异常。在 JavaScript 中，我们只需要在我们的项目中加入 ,try...catch..., 就可以处理了。,加入 ,try...catch..., 后，我们得到的代码是这样的,// 云函数入口文件,\r\n,const, cloud = require(,'wx-server-sdk',)\r\n\r\ncloud.init()\r\n\r\n,// 云函数入口函数,\r\nexports.main = ,async, (,event,, context) => {\r\n  ,const, img = (,await, cloud.downloadFile({\r\n    fileID:,event,.fileID\r\n  })).fileContent;\r\n  ,try, {\r\n    ,await, cloud.openapi.security.imgSecCheck({\r\n      media:{\r\n        contentType:,'image/png',,\r\n        ,value,:img\r\n      }\r\n    });\r\n    ,return, {\r\n      code: ,0,,\r\n      msg: ,\"ok\",\r\n    }\r\n  } ,catch, (err) {\r\n    ,return, {\r\n      code: ,1,,\r\n      msg: err\r\n    }\r\n  }\r\n},这段代码会在图片没有问题的时候回复一个 ,{ \"code\": 0, \"code\":\"ok\"}, ,如果图片有问题的话，就会返回 ,{\"code\":1,\"msg\":\"错误的原因\"}, 。,在这种情况下，你只需要在云函数的返回值中获取到 code ，如果等于 0 ，就说明用户上传的图片通过审核。如果返回 1 ，则说明用户的图片没有通过审核。,如何在业务系统中加入图片安全校验,前面的内容介绍了如何开发出一个图片安全校验的云函数，接下来，我们来看看如何在业务系统中接入这个功能。,实际上，我们有两种方式在业务系统中实现图片安全校验，一种是前置校验，一种是后置校验。,前置校验是指用户所提交的数据还没有提交到数据库前对图片进行校验，如果图片不合格，就不允许图片提交到数据库中。,后置校验则是指用户所提交的数据先提交到数据库中，并标记为审核中状态， 后续通过审核再修改状态为通过，从而让用户提交的内容在前台可见。,一般而言，推荐大家使用前置校验，这样可以避免错误的数据进入到你的数据库中，后续可能有风险。如果你的系统对于性能的要求特别特别的高，而安全校验接口返回速度慢一些，在这种情况下，你可以选择后置校验，降低用户在提交数据时的等待时间。,不过，后置校验的话，一定记得在前端进行查询的时候，将未审核的部分提醒用户，不可访问，避免出现审核问题。,总结,在小程序中接入图片安全校验功能很简单， 不过，在实际的接入过程中， 你还是需要配合自己的实际业务情况来选择如何接入。,如果你在开发的过程中有任何问题，欢迎在下方留言告诉我。,"
}
{
  "title": "dev环境测试动态小程序码 ",
  "author": "Rolan",
  "pub_time": "2020-4-2 00:32",
  "content": ",背景,\r\n,动态带参,小程序,二维码生成后如何在dev环境进行测试成为了很多人的疑惑，那么如何通过技术解决这个问题呢？接下来小编带大家来解决这个问题。,\r\n,解决思路,\r\n,\r\n,使用测试版本小程序码，修改默认路径为二维码要进入路径，加入路径参数,\r\n,通过增加自己小程序扫码能力，重新定义扫码,\r\n,\r\n,详细方案,\r\n,\r\n,\r\n,使用测试版本小程序码，修改默认路径为二维码要进入路径，加入路径参数,\r\n我们可以借助微信开发的能力进行测试码生成，将路径改写成我们想扫码进入的path + params的模式,这样我们在使用微信扫码就会直接跳转到我们的测试小程序，并且拿到我们的参数。,\r\n,\r\n,\r\n,通过增加自己小程序扫码能力，重新定义扫码,\r\n,\r\n,思路分析\r\n,demo展现\r\n,\r\n,\r\n,\r\n,\r\n,总结,\r\n,微信只支持线上小程序动态二维码生成，那么通过以上两种方式我们就可以成功进行dev环境的测试，解决了我们测试的难题。,\r\n,相关链接,\r\n,\r\n,示例代码地址,\r\n,服务端小程序二维码生成,\r\n,wepy+weui+redux实现小程序脚手架,\r\n,玩转微信小程序的位置授权,\r\n,如何玩转小程序登录体系,"
}
{
  "title": "谈谈小程序自动化 ",
  "author": "Rolan",
  "pub_time": "2020-4-8 00:02",
  "content": ",浏览器领域，我们有如selenium和puppeteer这样的库，可以自动化控制浏览器执行自动化脚本，以完成自动化端对端测试、定时自动化任务等。随着持续集成、持续部署也就是CI/CD的需求日益增长，自动化也成为必不可少的一环。,对于日益增长的,小程序,开发需求，我们能不能自动化控制小程序呢，进而达成自动测试、自动发布等任务呢？,针对微信小程序，自2019年5月，微信官方也开始提供了一个官方的自动化SDK： ,miniprogram-automator, 。这是一个通过NodeJS操控开发者工具以及远程真机中微信的SDK。通过这个SDK，可以控制小程序跳转到指定页面、获取小程序页面数据、获取小程序页面元素状态、触发小程序元素绑定事件、往 AppService 注入代码片段、调用 wx 对象上任意接口等等。,这个SDK通过脚本控制本机的微信开发者工具来近似达到自动化测试业务的目的，同时，也可通过远程控制真机，达到真机测试的目的。,原理与初步体验,我们首先来体验一下这个SDK。,首先，你需要确保你安装了微信开发者工具，并且版本大于1.02.1907232，并设置你的基础库版本在2.7.3以上，同时请安装NodeJS 8.0以上的版本。,我们知道，微信开发者工具提供了命令行与 HTTP 服务两种接口供外部调用，开发者可以通过命令行或 HTTP 请求指示工具进行登录、预览、上传等操作。,SDK通过命令行方式将微信开发者工具调起，再通过外部方式导入目标项目。微信开发者工具通过读取目标项目的project.config.js，初始化项目。并读取启动命令的 ,--auto-port, 参数，使得SDK可以通过此端口的Websocket服务，实现与对应的目标小程序调试窗口进行交互。,这就是 ,miniprogram-automator, 工作的大致原理。,感兴趣的读者可以尝试使用微信开发者工具的cli方式来尝试运行此命令。,cli auto --project { 项目路径 } --auto-port { websocket的端口 },为了运行上述命令，我们需要找到微信开发者工具的安装目录。不同的操作系统位置不同。Mac位于:<安装路径>/Contents/MacOS/cli，windows位于: <安装路径>/cli.bat。对于经常使用的读者，建议将cli所在的目录放在系统的环境变量中。,你可能遇到IDE服务超时的情况。因此，为了保证开发者工具能够通过命令行打开，需要将开发者工具的HTTP服务调用接口打开。,打开的方式是，进入微信开发者工具，选择：设置 > 安全设置。在服务端口中选择：打开。此时，微信开发者工具会自动指定一个可用的端口号。,细心的读者会发现这里又出现了一个“端口”。不同于上面提到的端口，这个端口是IDE提供对外服务的端口。如上图所示，36146是IDE服务的端口。你在启动IDE之后，可以访问 ,http://127.0.0.1:36146/open,你的IDE就会聚焦到你的面前。 ,http://127.0.0.1:36146/, 是IDE服务的根域名，open是命令，读者可以参考 ,命令索引, 通过不同的URL发出不同的命令。,好，安装好了SDK，我们来操练一下：,首先，我们init一个npm库如 ,auto, ，通过： ,npm i miniprogram-automator --save-dev, 或 ,yarn add miniprogram-automator --dev, 即可安装 ,miniprogram-automator, 。,接下来，我们下载一个 ,微信示例程序, ，并解压在~/demo-miniapp/,下面，我们新建一个文件，如index.js，内容如下：,const, automator = ,require,(,'miniprogram-automator',)\r\n\r\nautomator.launch({\r\n  ,projectPath,: ,'~/demo-miniapp/',, ,// 项目文件地址,\r\n}).then(,async, miniProgram => {\r\n  ,const, page = ,await, miniProgram.reLaunch(,'/page/tabBar/component/index',)\r\n  ,await, page.waitFor(,500,)\r\n  ,const, element = ,await, page.$(,'.kind-list-text',)\r\n  ,console,.log(,await, element.attribute(,'class',))\r\n  ,await, element.tap()\r\n  ,await, page.waitFor(,500,)\r\n\r\n  ,await, miniProgram.close()\r\n}),现在，让我们运行起来。 ,node index.js, 。我们看到，IDE自动启动，并加载了我们的项目文件，并自动地点开了第一个项目，过一段时间之后，程序自动的退出。,这就是我们对于自动运行的初步体验。,API组成,截至目前（2020年4月初）最新的SDK的API主要分四个模块：Automater、MiniProgram、Page和Element等。,Automator 模块提供了启动及连接开发者工具的方法。开发者可以对连接地址、端口号、项目路径等作出设置。归根结底是对于cli的包装。详见： ,Automator,MiniProgram提供对小程序的控制。提供以下几类支持，详见： ,MiniProgram, ：,路由方法。控制小程序的跳转,系统信息。与API的wx.getSystemInfo等价,转调、mock以及恢复微信API对象wx上的方法,在APP对象上注入方法、向小程序暴露方法,截图、滚动等方法,测试真机、截图、测试账号、关闭等方法,打印事件、报错事件,Page 模块提供了控制小程序页面的方法。提供以下几类支持，详见： ,Page, ：,页面路径方法,页面元素选取方法,页面元素/逻辑钩子方法,页面数组方法,页面行为方法,页面方法调用代理,Element 模块提供了控制小程序页面元素的方法。提供以下几类支持，详见： ,Element, ：,元素本身属性获取方法,元素子代与后继选择器方法,元素事件触发方法,元素数据访问方法,元素方法访问代理方法,可以看出，除Automator之外，每个API模块都在自己的领域内提供对小程序自身内容的访问特性以及扩充特性。这比较类似于Pupputeer的API设定。,与测试框架的整合,miniprogram-automator, 本身不提供测试框架，我们可以选用熟悉的测试框架与之整合。这里我们以jest为例。其他诸如mocha、jasmine、Cucumber都比较类似。,现在，在我们之前的项目 ,auto, 里安装jest。 ,npm i jest -g, 或 ,yarn global add jest,简单科普下jest的工作原理。在项目中，jest识别三种测试文件：,以.test.js结尾的文件,以.spec.js结尾的文件,放到 ,tests, 文件夹中的文件。,Jest 在进行测试的时候，它会在整个项目进行查找，只要碰到这三种文件它都会执行。Jest有以下设定：,一个describe块称为一个“测试套件”。,一个it/test块，称为“测试用例”。测试用例是测试的最小单位。,每个测试文件应至少包含一个describe或一个it/test块。,一个describe块应至少包含一个或多个it/test块。,每个测试用例，可以组合各种断言来判定是否符合预期。,Jest 测试提供了一些测试的生命周期 API。可以辅助我们在每个 case 的开始和结束做一些处理。 这样，在进行一些和数据相关的测试时，可以在测试前准备一些数据，在测试后，清理测试数据。 4 个主要的生命周期函数：,afterAll(fn, timeout): 当前文件中的所有测试执行完成后执行 fn, 如果 fn 是 promise，jest 会等待 timeout 毫秒，默认 5000,afterEach(fn, timeout): 每个 test 执行完后执行 fn，timeout 含义同上,beforeAll(fn, timeout): 同 afterAll，不同之处在于在所有测试开始前执行,beforeEach(fn, timeout): 同 afterEach，不同之处在于在每个测试开始前执行,回到 ,miniprogram-automator, 。我们可以在 ,auto, 项目中加入一个index.spec.js文件。,const, automator = require(,'miniprogram-automator',)\r\nlet miniProgram, page\r\n\r\nbeforeAll(,async, () => {\r\n    miniProgram = ,await, automator.launch({\r\n        projectPath: ,'/Users/liuguanyu/devspace/demo-miniapp/',\r\n    })\r\n    page = ,await, miniProgram.reLaunch(,'/page/tabBar/component/index',)\r\n    ,await, page.waitFor(,500,)\r\n}, ,50000,)\r\n\r\nafterAll(,async, () => {\r\n    ,await, miniProgram.close()\r\n}),现在，你在 ,auto, 下运行 ,jest, 会报错。,意思是需要我们增加至少一个测试套件或测试用例。,为此我们增加一个测试套件，并增加一些测试用例，修改如下：,const, automator = ,require,(,'miniprogram-automator',)\r\n,let, miniProgram, page\r\n\r\nbeforeAll(,async, () => {\r\n    miniProgram = ,await, automator.launch({\r\n        ,projectPath,: ,'/Users/liuguanyu/devspace/demo-miniapp/',\r\n    })\r\n    page = ,await, miniProgram.reLaunch(,'/page/tabBar/component/index',)\r\n    ,await, page.waitFor(,500,)\r\n}, ,50000,)\r\n\r\ndescribe(,\"测试微信小程序\",, () => {\r\n    ,// 1. 测试顶部描述,\r\n    it(,\"标题栏\",, ,async, () => {\r\n        ,const, desc = ,await, page.$(,'.index-desc',)\r\n        ,// 要求测试标签名必须为view,\r\n        expect(desc.tagName).toBe(,'view',)\r\n        ,// 要求测试内容包含文字以下将展示小程序官方组件能力,\r\n        expect(,await, desc.text()).toContain(,'以下将展示小程序官方组件能力',)\r\n    })\r\n\r\n    ,// 2. 测试列表项,\r\n    it(,'列表项',, ,async, () => {\r\n        ,const, lists = ,await, page.$$(,'.kind-list-item',)\r\n        ,// 测试共有7个列表项,\r\n        expect(lists.length).toBe(,7,)\r\n        ,const, list = ,await, lists[,0,].$(,'.kind-list-item-hd',)\r\n        ,//第一个列表元素的标题应该是“视图窗器”,\r\n        expect(,await, list.text()).toBe(,'视图容器',)\r\n    })\r\n\r\n    ,// 3. 测试列表项行为,\r\n    it(,'列表行为',, ,async, () => {\r\n        ,const, listHead = ,await, page.$(,'.kind-list-item-hd',)\r\n\r\n        ,// 点击应展开未展开项,\r\n        expect(,await, listHead.attribute(,'class',)).toBe(,'kind-list-item-hd',)\r\n        ,await, listHead.tap()\r\n        ,await, page.waitFor(,200,)\r\n        expect(,await, listHead.attribute(,'class',)).toBe(\r\n            ,'kind-list-item-hd kind-list-item-hd-show',,\r\n        )\r\n\r\n        ,// 再次点击应合上,\r\n        ,await, listHead.tap()\r\n        ,await, page.waitFor(,200,)\r\n        expect(,await, listHead.attribute(,'class',)).toBe(,'kind-list-item-hd',)\r\n\r\n        ,// 点击子列表项应该会跳转到指定页面,\r\n        ,await, listHead.tap()\r\n        ,await, page.waitFor(,200,)\r\n        ,const, item = ,await, page.$(,'.index-bd navigator',)\r\n        ,await, item.tap()\r\n        ,await, page.waitFor(,1500,)\r\n        expect((,await, miniProgram.currentPage()).path).toBe(,'page/component/pages/view/view',)\r\n    })\r\n\r\n    ,// 4. 验证wxml方法和setData方法及快照比对,\r\n    it(,'验证WXML',, ,async, () => {\r\n        ,const, element = ,await, page.$(,'page',)\r\n        expect(,await, element.wxml()).toMatchSnapshot()\r\n        ,await, page.setData({\r\n            ,list,: []\r\n        })\r\n        expect(,await, element.wxml()).toMatchSnapshot()\r\n    })\r\n\r\n    ,// 5. mock方法测试并还原,\r\n    it(,'伪造请求结果',, ,async, () => {\r\n        ,// 伪造请求数据,\r\n        ,const, mockData = [{\r\n            ,rule,: ,'testRequest',,\r\n            ,result,: {\r\n                ,data,: ,'test',,\r\n                ,cookies,: [],\r\n                ,header,: {},\r\n                ,statusCode,: ,200,,\r\n            }\r\n        }]\r\n\r\n        ,// mock方法,\r\n        ,await, miniProgram.mockWxMethod(\r\n            ,'request',,\r\n            ,function, (,obj, data,) ,{\r\n                ,for, (,let, i = ,0,, len = data.length; i < len; i++) {\r\n                    ,const, item = data[i]\r\n                    ,const, rule = ,new, ,RegExp,(item.rule)\r\n                    ,if, (rule.test(obj.url)) {\r\n                        ,return, item.result\r\n                    }\r\n\r\n                    ,// 没命中规则的真实访问后台,\r\n                    ,return, ,new, ,Promise,(,resolve, =>, {\r\n                        obj.success = ,res, =>, resolve(res)\r\n                        obj.fail = ,res, =>, resolve(res)\r\n                        ,this,.origin(obj)\r\n                    })\r\n                }\r\n            },\r\n            mockData\r\n        )\r\n\r\n        ,// 请求mock的方法,\r\n        ,const, result = ,await, miniProgram.callWxMethod(,'request',, {\r\n            ,url,: ,'https://14592619.qcloud.la/testRequest',,\r\n        })\r\n        expect(result.data).toBe(,'test',)\r\n        ,// 还原方法,\r\n        ,await, miniProgram.restoreWxMethod(,'request',)\r\n    }, ,30000,)\r\n})\r\n\r\nafterAll(,async, () => {\r\n    ,await, miniProgram.close()\r\n}),此时，我们在 ,auto, 目录下再次运行 ,jest, ，则得到如下结果：,我们看到所有的测试都已通过。,真机测试,真机测试可以自动测试以及扫码测试。此时可以在beforeAll里面加入 ,await miniProgram.remote(true), 。这个true如果不写，就需要用真机扫码测试。当编译好之后，开发者工具会自动将小程序和调试工具发送到真机。并在侧边增加了测试条。,当不写true时候，运行到remote时，会弹出这样的对话框：,小结,发布3年多，微信小程序已经从微信生态的一环，逐步向多领域渗透。随着开发者的日益增多，面向开发的工具也逐步完善。本文试图管中窥豹，给大家介绍了微信自动化的主要环节。时至今日，小程序已经成长为一种重要的产品形式和生态环境。越来越多的小程序平台正在自己的领域以不同的形式给小程序这个产品形式添砖加瓦。小程序生态和开发环节的完善和成长，也需要广大平台、开发者共同努力，将这一Created in China 的生态体系发扬光大。,"
}
{
  "title": "简化微信小程序用户授权 ",
  "author": "Rolan",
  "pub_time": "2020-3-20 00:15",
  "content": ",在开发,小程序,中，获取用户授权是一个繁琐的步骤，觉得不错，请点赞哦,相关API,wx,.getSetting,({\r\n  ,success, (res) {\r\n    ,console,.log,(res.authSetting)\r\n    ,// res.authSetting = {,\r\n    ,//   \"scope.userInfo\": true,,\r\n    ,//   \"scope.userLocation\": true,\r\n    ,// },\r\n  }\r\n})\r\n复制代码,// 可以通过 wx.getSetting 先查询一下用户是否授权了 \"scope.record\" 这个 scope,\r\n,wx,.getSetting,({\r\n  ,success,(res) {\r\n    ,if, (!res.authSetting[,'scope.record',]) {\r\n      ,wx,.authorize,({\r\n        ,scope,: ,'scope.record',,\r\n        success () {\r\n          ,// 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问,\r\n          wx.startRecord()\r\n        }\r\n      })\r\n    }\r\n  }\r\n})\r\n复制代码,Promisify相关API,微信小程序的API都是回调函数，一不小心就是回调地狱。我们可以用Promise封装下,const, promisify = ,fn,=>,(,arg={},)=>,new, ,Promise,(,(,resolve,reject,)=>,{\r\n  arg.success=,function,(,res,),{\r\n    resolve(res)\r\n  }\r\n  arg.fail=,function,(,err,),{\r\n    reject(err)\r\n  }\r\n  fn(arg)\r\n})\r\n复制代码,使用：,const, wxGetSetting = promisify(wx.getSetting)\r\nwxGetSetting().then(,res,=>,console,.log(res))\r\n复制代码,解释,// promisify接受一个fn函数,\r\n,const, promisify = ,function,(,fn,),{\r\n,// promisify返回一个函数，这个函数可以接受一个arg参数,\r\n,// arg默认是空对象，因为微信小程序api都是接受一个对象参数的,\r\n  ,return, ,function,(,arg={},),{\r\n    ,// 该参数执行后，返回一个promise对象,\r\n    ,return, ,new, ,Promise,(,(,resolve,reject,)=>,{\r\n      ,// 给参数加上success和fail,\r\n      arg.success=,function,(,res,),{\r\n        resolve(res)\r\n      }\r\n      arg.fail=,function,(,fail,),{\r\n        reject(fail)\r\n      }\r\n      ,// 执行fn,\r\n      fn(arg),// fn是传进来的wx.getSetting,\r\n    })\r\n  }\r\n}\r\n复制代码,简化授权,const, wxGetSetting = promisify(wx.getSetting)\r\n,const, wxAuthorize = promisify(wx.authorize)\r\n,function, ,myAuthorize,(,authSetting,) ,{\r\n    ,return, ,new, ,Promise,(,(,resolve, reject,) =>, {\r\n        wxGetSetting().then(,res, =>, {\r\n            ,if, (res.authSetting[authSetting]) {\r\n                resolve(,\"ok\",)\r\n            } ,else, {\r\n                ,return, wxAuthorize({\r\n                    ,scope,: authSetting\r\n                }).then(,res, =>, {\r\n                    resolve(,\"ok\",)\r\n                }).catch(,err, =>, {\r\n                    reject(,\"fail\",)\r\n                })\r\n            }\r\n        })\r\n\r\n    })\r\n}\r\n复制代码,使用：,myAuthorize(,\"scope.userLocation\",)\r\n  .then(,res,=>,console,.log(res))\r\n\t.catch(,err,=>,console,.log(err))\r\n复制代码,"
}
{
  "title": "小程序测试全攻略，还学不会你来找我（含实操代码） ",
  "author": "Rolan",
  "pub_time": "2020-3-20 00:20",
  "content": ",此文章来源于项目官方公众号：“AirtestProject”,\r\n版权声明：允许转载，但转载必须保留原链接；请勿用作商业或者非法用途,\r\n,\r\n,前言,\r\n,每隔几天，小编都会收到同学们对于,小程序,测试的灵魂追问：Airtest支持小程序测试吗？用Poco不能很好地对小程序进行UI识别怎么办？公众号菜单里面的H5页面能用Poco测吗？,\r\n,在此，小编统一回复：,\r\n,\r\n,Airtest是支持小程序测试的；,\r\n,小程序是基于腾讯的X5内核开发的，默认情况下，Poco对小程序的元素不能很好地识别，需要进入TBS调试页面设置才能更好识别小程序的控件；,\r\n,进行TBS设置之后，公众号菜单的H5页面也能够用Poco框架进行测试。,\r\n,\r\n,所以，在下文中，小编会详细介绍如何用Airtest和Poco来对小程序进行测试。,\r\n,用Airtest测试小程序,\r\n,Airtest是基于图像识别来进行UI测试的，所以只要借助IDE提供的各种便捷功能，我们就可以很好地对小程序进行测试，如下是一个测试的小例子：,\r\n,# -*- encoding=utf8 -*-,\r\n__author__ = ,\"19617\",\r\nfrom airtest.core.api import *\r\nauto_setup(__file__)\r\n,# 点击微信图标,\r\ntouch(Template(r,\"tpl1584336781668.png\",, record_pos=(0.353, -0.526), resolution=(1080, 2244)))\r\n,# 下拉滑动进入小程序页面,\r\nswipe(Template(r,\"tpl1584336820818.png\",, record_pos=(0.004, -0.75), resolution=(1080, 2244)), vector=[0.0044, 0.5737])\r\nsleep(1.0)\r\n,# 点击目标小程序,\r\ntouch(Template(r,\"tpl1584336839508.png\",, record_pos=(-0.344, -0.427), resolution=(1080, 2244)))\r\nsleep(1.0)\r\n\r\n,# 等到页面上某个元素出现,\r\n,wait,(Template(r,\"tpl1584336861709.png\",, record_pos=(0.007, -0.689), resolution=(1080, 2244)))\r\nsleep(1.0)\r\n\r\ntouch(Template(r,\"tpl1584336875201.png\",, record_pos=(-0.014, -0.454), resolution=(1080, 2244)))\r\nsleep(1.0)\r\n\r\n,# 在搜索框输入文字并执行搜索,\r\ntext(,\"蛋糕\",,search=True)\r\n\r\nassert_exists(Template(r,\"tpl1584352235391.png\",, record_pos=(0.002, -0.453), resolution=(1080, 2244)), ,\"找到目标\",)\r\n\r\n,print,(,\"运行成功\",)\r\n,复制代码,尽管上述的例子非常简单，但利用Airtest来对小程序进行测试的时候，我们仍需要注意以下几点：,\r\n,\r\n,并不是所有小程序都适合用Airtest来进行测试，如果小程序的页面样式经常发生变化，那么图像脚本也经常要根据样式变化而进行更新维护；,\r\n,如果脚本中存在多个连续的图像识别操作，特别是操作会发生页面加载、页面切换等情况，最好在连续操作之间加入sleep(1.0)，给一定的缓冲时间让页面稳定，可以大大减少因为页面未加载完全而导致的图像识别失败；,\r\n,对于无法用Airtest完成的测试操作，我们可以考虑结合Poco来完成,\r\n,\r\n,用Pcoco测试小程序,\r\n,开篇我们就提到过，微信和QQ内置的浏览器内核不是Android原生的WebView，而是他们自家的 X5 WebView 内核。我们需要切换到系统WebView内核，这样Poco才能更好地识别出小程序的各种UI控件。,\r\n,很多同学未进行设置，就直接用Poco去获取控件，很可能会遇到下图中的情况：,\r\n,小程序页面内的很多元素都不能获取到。,\r\n,如何进行设置,\r\n,① 打开微信中任意一个聊天框，输入 debugtbs.qq.com，点击进入TBS调试页面，再点击页面内的“安装线上内核”：,\r\n,\r\n,② 安装成功后，我们需要,重启微信,才可以生效；,\r\n,③ 再次进去刚才的TBS调试页面，检查我们的设置是否生效，点击“查看版本信息”，版本信息为 0(null) 则设置成功：,\r\n,\r\n,设置成功以后即可用Poco对小程序进行测试。,\r\n,\r\n,Poco测试小程序实操,\r\n,依旧以上述的小程序为例，来看看用poco框架如何测试小程序：,\r\n,# -*- encoding=utf8 -*-,__author__ = ,\"19617\",\r\nfrom airtest.core.api import *\r\n\r\nfrom poco.drivers.android.uiautomation import AndroidUiautomationPoco\r\npoco = AndroidUiautomationPoco(use_airtest_input=True, screenshot_each_action=False)\r\nauto_setup(__file__)\r\n\r\n,# 传入微信的包名启动微信app,\r\nstart_app(,\"com.tencent.mm\",)\r\n,# 下滑进去小程序页面,\r\nswipe((550,250),(550,1200))\r\nsleep(2.0)\r\n\r\n,# 点击下厨房小程序,\r\npoco(,\"com.tencent.mm:id/cud\",).offspring(,\"com.tencent.mm:id/dai\",).child(,\"android.widget.RelativeLayout\",).offspring(,\"com.tencent.mm:id/le\",).offspring(,\"com.tencent.mm:id/lh\",).child(,\"android.widget.LinearLayout\",)[2].offspring(,\"com.tencent.mm:id/eko\",).child(,\"android.widget.RelativeLayout\",)[0].offspring(,\"com.tencent.mm:id/cik\",).click()\r\n\r\nsleep(2.0)\r\n,# 点击搜索框,\r\npoco(text=,\"今天想吃点什么？\",).click()\r\nsleep(1.0)\r\n\r\n,# 再次点击搜索框,\r\npoco(,\"android.widget.EditText\",).click()\r\n\r\nsleep(1.0)\r\n\r\n,# 输入搜索词“蛋糕”,\r\npoco(,\"android.widget.EditText\",).set_text(,\"蛋糕\",)\r\n\r\n,# 点击搜索,\r\npoco(text=,\"搜索\",).click()\r\n\r\n,# 打印找到第一个配方的标题,\r\n,print,(poco(text=,\"超容易上手的古早蛋糕\",).get_text())\r\n,复制代码,例子中有以下几点需要注意：,\r\n,\r\n,start_app()需要传入的参数是APP的包名，关于如何获取APP包名大家可以自行百度，方法很多；,\r\n,连续操作之间仍需要适当使用一些sleep(1.0)，防止页面切换时UI树没来得及刷新导致下一步操作的控件查找失败。,\r\n,\r\n,测试公众号菜单的H5页面,\r\n,如上，通过设置切换到系统WebView内核之后，Poco也能够获取微信公众号菜单的H5页面元素：,\r\n,小结,\r\n,① TBS调试只适用于Android系统，iOS暂不支持；,\r\n,② 在小程序测试的实操中，我们可以灵活地交替使用Airtest和Poco脚本，比如：有些编辑框无法使用Poco的set_text接口，我们可以先使用poco进行点击操作，再用Airtest的text接口。,\r\n,③上文使用设备详情：IDE版本1.2.3；手机型号MI 8 SE，安卓9；微信版本7.0.12。,\r\n,以上就是本期教程的所有内容，如有疑问可以在我们的官方公众号内留言，或者加入我们的开发者交流Q群（1017250147），然后在群内提问即可。（PS：提问时请描述详细情况最好附上截图方便定位问题哦~）,"
}
{
  "title": "微信小程序开发系列教程第七章：编辑名片页面开发 ",
  "author": "admin",
  "pub_time": "2016-10-12 22:14",
  "content": ",编辑名片有两条路径，分为新增名片流程与修改名片流程。,用户手填新增名片流程：,首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。,新增名片页面 1 基本布局如下：,取到 userId。,使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。,也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。,这里绑定了自带的模态框提示组件。,其中 modalHidden2 是模态框开关。,另外 proptText 是需要提示的内容。,即使很多输入框也支持数据动态改变，非常方便。,实际效果，非常快捷，比以前省去很多事情，编写,小程序,，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。,最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。,设置的直接是背景图片。,提交表单与跳转。,提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。,这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。,同样也是一些数据绑定以及验证效果。,实际渲染效果可以看到。,这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。,修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：,名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：,姓名手机必填模块：,个人信息模块，直接循环（block）出来：,Onload 时我们请求必填与选填数据：,* requiredGroup 必填中文信息,* notRequiredGroup 选题中文信息,* requiredGroupEn 必填英文信息,* notRequiredGroupEn 选题英文信息,```,//请求名片对应的公司的中文信息的属性组数据，分为必填和选填,//选题项变量以 no 开头,requester.getOfflineCardInfoGroupFields(userId, cardId,,function (res) {,//debugger,var userName = res.card.userName;,var mobile = res.card.mobile;,var requiredGroup = res.requiredGroupCh;,var notRequiredGroup = res.notRequiredGroupCh;,var requiredGroupEn = res.requiredGroupEn;,var notRequiredGroupEn = res.notRequiredGroupEn;,var reqLen = requiredGroup.fields.length;,var nreqLen = notRequiredGroup.fields.length;,var reqLenEn = requiredGroupEn.fields.length;,var nreqLenEn = notRequiredGroupEn.fields.length;,self.setData({,userName: userName,,mobile: mobile,,requireFields: requiredGroup.fields,,notRequireFields: notRequiredGroup.fields,,requireFieldsEn: requiredGroupEn.fields,,notRequireFieldsEn: notRequiredGroupEn.fields,,l1: reqLen,,l2: nreqLen + reqLen,,l3: reqLenEn + nreqLen + reqLen,});,self.forceUpdate();,}, function (code, msg) {,console.info(\"code=\" + code + \"&msg=\" + msg);,});,```,中英文信息必填与选填渲染：,这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。,今天再回去理下首页 A、B、C 定点跳转功能实现方法。,首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：,数据 sort，和 group.name 数据一样：,这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。,点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。,首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。,可以看下：,这个 group.name==sortmsg，等于就是 A==A,B==B 同理。,在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。,跳转功能基本实现（ohter 就是 # 底部）。,"
}
